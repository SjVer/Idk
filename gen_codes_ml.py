from re import findall, DOTALL
from datetime import datetime
from typing import List

SOURCE_FILE = "somc/lib/report/error.ml"
OUT_FILE = "somc/lib/report/codes.ml"

HEADER = f"(* File generated by gen_codes_ml.py on {datetime.now().ctime()}. *)\n"
IMPORTS = "\nopen Error\n"
ERR_TO_INT_DECL_FMT = "\nlet int_from_{name}_error : {type} -> int = function\n" 
ERR_TO_INT_BODY_FMT = "  | {name}{underscore} -> {index}\n"
ANY_TO_INT_DECL_FMT = "\nlet int_from_error = function\n"
ANY_TO_INT_BODY_FMT = "  | {uppername}_error e -> int_from_{name}_error e\n"
FROM_INT_DECL_FMT = "\nlet error_name_from_int = function\n"
FROM_INT_BODY_FMT = "  | {index} -> Some (\"{kind}\", \"{name}\")\n"
FROM_INT_TAIL_FMT = "  | _ -> None"
GET_CODE_OPT_FN = """
let get_code_opt = function
  | Other_error _ -> None
  | e -> Some (int_from_error e)"""

ENUM_REGEX = r"type (\w+)_error =\n(.*?)\nlet"
VARIANT_REGEX = r"\s*(\w+)(?: (.*?)\n)?"
PROPERTIES_REGEX = r"^(of [^\(]*)?(?:\(\*\+(.*?)\*\))?.*$"

class Variant:
    index: int
    name: str
    has_value: bool
    extra_text: str

class Enum:
    name: str
    variants: List[Variant]

def read_enums(source: str):
    enums = []
    
    for m in findall(ENUM_REGEX, source, DOTALL):
        eenum = Enum()
        eenum.name = m[0]
        eenum.variants = []
        base_index = (len(enums) + 1) * 100

        for v in findall(VARIANT_REGEX, m[1]):
            variant = Variant()
            variant.index = base_index + len(eenum.variants) + 1
            variant.name = v[0]
            
            props = findall(PROPERTIES_REGEX, v[1])[0]
            variant.has_value = len(props[0]) > 0
            variant.extra_text = props[1]

            eenum.variants.append(variant)
        
        enums.append(eenum)

    return enums
    
def print_enums(enums: List[Enum]):
    print(f"found {len(enums)} error enums:\n")

    for e in enums:
        print(f"  {e.name} error: ({len(e.variants)} variants)")

        for v in e.variants:
            has_value = " _" if v.has_value else ""
            print(f"    {v.index}: {v.name}{has_value} \"{v.extra_text}\"")

        print()

def generate_file(enums: List[Enum]):
    txt = HEADER
    txt += IMPORTS
    
    # let int_from_{name}_error = function ...
    for e in enums:
        txt += ERR_TO_INT_DECL_FMT.format(
            name = e.name,
            type = e.name + "_error"
        )

        for v in e.variants:
            txt += ERR_TO_INT_BODY_FMT.format(
                name = v.name,
                underscore = ' _' if v.has_value else '',
                index = v.index
            )

    # let int_from_error = function ...
    txt += ANY_TO_INT_DECL_FMT
    for e in enums:
        txt += ANY_TO_INT_BODY_FMT.format(
            uppername = e.name.title(),
            name = e.name)

    # let error_name_from_int = function ...
    txt += FROM_INT_DECL_FMT
    for e in enums:
        for v in e.variants:
            name = " ".join([n.lower() for n in v.name.split('_')])
            if v.extra_text: name += ' ' + v.extra_text

            txt += FROM_INT_BODY_FMT.format(
                index = v.index,
                kind = e.name,
                name = name
            )
    txt += FROM_INT_TAIL_FMT
    
    txt += GET_CODE_OPT_FN
    
    # print("output:\n")
    # print("  " + "  ".join(txt.splitlines(True)) + "\n")
    return txt

def main():
    with open(SOURCE_FILE, "r") as f:
        source = f.read()
    
    enums = read_enums(source)
    print_enums(enums)
    
    with open(OUT_FILE, 'w') as f:
        f.write(generate_file(enums))
    
if __name__ == "__main__":
    main()