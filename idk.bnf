<extra_str(symb)> ::= symb

<extra_sig(symb)> ::= symb

<extra_cstr(symb)> ::= symb

<extra_csig(symb)> ::= symb

<extra_def(symb)> ::= symb

<extra_text(symb)> ::= symb

<extra_rhs(symb)> ::= symb

<mkrhs(symb)> ::= symb

<text_str(symb)> ::= symb

<text_str_SEMISEMI> ::= SEMISEMI

<text_sig(symb)> ::= symb

<text_sig_SEMISEMI> ::= SEMISEMI

<text_def(symb)> ::= symb

<top_def(symb)> ::= symb

<text_cstr(symb)> ::= symb

<text_csig(symb)> ::= symb

<mark_rhs_docs(symb)> ::= symb

<op(symb)> ::= symb

<mkloc(symb)> ::= symb

<mkexp(symb)> ::= symb

<mkpat(symb)> ::= symb

<mktyp(symb)> ::= symb

<mkstr(symb)> ::= symb

<mksig(symb)> ::= symb

<mkmod(symb)> ::= symb

<mkmty(symb)> ::= symb

<mkcty(symb)> ::= symb

<mkctf(symb)> ::= symb

<mkcf(symb)> ::= symb

<mkclass(symb)> ::= symb

<wrap_mkstr_ext(symb)> ::= symb

<wrap_mksig_ext(symb)> ::= symb

<mk_directive_arg(symb)> ::= symb

<iloption(X)> ::= [X]

<reversed_llist(X)> ::= X*

<llist(X)> ::= <reversed_llist(X)>

<reversed_nonempty_llist(X)> ::= X+

<nonempty_llist(X)> ::= <reversed_nonempty_llist(X)>

<inline_reversed_separated_nonempty_llist(separator, X)> ::= X (separator X)*

<reversed_separated_nonempty_llist(separator, X)> ::= <inline_reversed_separated_nonempty_llist(separator,
                                                      X)>

<separated_nonempty_llist(separator, X)> ::= <reversed_separated_nonempty_llist(separator,
                                             X)>

<inline_separated_nonempty_llist(separator, X)> ::= <inline_reversed_separated_nonempty_llist(separator,
                                                    X)>

<reversed_separated_nontrivial_llist(separator, X)> ::= <reversed_separated_nontrivial_llist(separator,
                                                        X)> separator X
                                                      | X separator X

<separated_nontrivial_llist(separator, X)> ::= <reversed_separated_nontrivial_llist(separator,
                                               X)>

<separated_or_terminated_nonempty_list(delimiter, X)> ::= X [delimiter]
                                                        | X delimiter
                                                          <separated_or_terminated_nonempty_list(delimiter,
                                                          X)>

<reversed_preceded_or_separated_nonempty_llist(delimiter, X)> ::= [delimiter]
                                                                  X
                                                                | <reversed_preceded_or_separated_nonempty_llist(delimiter,
                                                                  X)>
                                                                  delimiter X

<preceded_or_separated_nonempty_llist(delimiter, X)> ::= <reversed_preceded_or_separated_nonempty_llist(delimiter,
                                                         X)>

<reversed_bar_llist(X)> ::= X(<epsilon>)
                          | X(BAR)
                          | <reversed_bar_llist(X)> X(BAR)

<bar_llist(X)> ::= <reversed_bar_llist(X)>

<xlist(A, B)> ::= A B*

<listx(delimiter, X, Y)> ::= X [delimiter]
                           | X delimiter Y [delimiter]
                           | X delimiter <listx(delimiter, X, Y)>

<implementation> ::= <structure> EOF

<interface> ::= <signature> EOF

<toplevel_phrase> ::= <extra_str(<text_str(<str_exp>)>)> SEMISEMI
                    | <extra_str(<text_str(<structure_item>)>*)> SEMISEMI
                    | <toplevel_directive> SEMISEMI
                    | EOF

<use_file> ::= <extra_def(<optional_use_file_standalone_expression>
               <use_file_element>*)> EOF

<optional_use_file_standalone_expression> ::= <iloption(<text_def(<top_def(<str_exp>)>)>)>

<use_file_element> ::= SEMISEMI <optional_use_file_standalone_expression>
                     | <text_def(<top_def(<structure_item>)>)>
                     | <text_def(<mark_rhs_docs(<toplevel_directive>)>)>

<parse_module_type> ::= <module_type> EOF

<parse_module_expr> ::= <module_expr> EOF

<parse_core_type> ::= <core_type> EOF

<parse_expression> ::= <seq_expr> EOF

<parse_pattern> ::= <pattern> EOF

<parse_mty_longident> ::= <mty_longident> EOF

<parse_val_longident> ::= <val_longident> EOF

<parse_constr_longident> ::= <constr_longident> EOF

<parse_mod_ext_longident> ::= <mod_ext_longident> EOF

<parse_mod_longident> ::= <mod_longident> EOF

<parse_any_longident> ::= <any_longident> EOF

<functor_args> ::= <reversed_nonempty_llist(<functor_arg>)>

<functor_arg> ::= LPAREN RPAREN
                | LPAREN <mkrhs(<module_name>)> COLON <module_type> RPAREN

<module_name> ::= UIDENT
                | UNDERSCORE

<module_expr> ::= STRUCT <attributes> <structure> END
                | STRUCT <attributes> <structure> error
                | FUNCTOR <attributes> <functor_args> MINUSGREATER
                  <module_expr>
                | <paren_module_expr>
                | <module_expr> <attribute>
                | <mkmod(<mkrhs(<mod_longident>)> | <module_expr>
                  <paren_module_expr> | <module_expr> LPAREN RPAREN |
                  <extension>)>

<paren_module_expr> ::= LPAREN <module_expr> COLON <module_type> RPAREN
                      | LPAREN <module_expr> COLON <module_type> error
                      | LPAREN <module_expr> RPAREN
                      | LPAREN <module_expr> error
                      | LPAREN VAL <attributes> <expr_colon_package_type>
                        RPAREN
                      | LPAREN VAL <attributes> <expr> COLON error
                      | LPAREN VAL <attributes> <expr> COLONGREATER error
                      | LPAREN VAL <attributes> <expr> error

<expr_colon_package_type> ::= <expr>
                            | <expr> COLON <package_type>
                            | <expr> COLON <package_type> COLONGREATER
                              <package_type>
                            | <expr> COLONGREATER <package_type>

<structure> ::= <extra_str(<optional_structure_standalone_expression>
                <structure_element>*)>

<optional_structure_standalone_expression> ::= <iloption(<mark_rhs_docs(<text_str(<str_exp>)>)>)>

<str_exp> ::= <seq_expr> <post_item_attributes>

<structure_element> ::= <text_str_SEMISEMI>
                        <optional_structure_standalone_expression>
                      | <text_str(<structure_item>)>

<structure_item> ::= <let_bindings(<ext>)>
                   | <mkstr(<item_extension> <post_item_attributes> |
                     <floating_attribute>)>
                   | <wrap_mkstr_ext(<primitive_declaration> |
                     <value_description> | <type_declarations> |
                     <str_type_extension> | <str_exception_declaration> |
                     <module_binding> | <rec_module_bindings> |
                     <module_type_declaration> | <open_declaration> |
                     <class_declarations> | <class_type_declarations> |
                     <include_statement(<module_expr>)>)>

<module_binding> ::= MODULE <ext> <attributes> <mkrhs(<module_name>)>
                     <module_binding_body> <post_item_attributes>

<module_binding_body> ::= EQUAL <module_expr>
                        | <mkmod(COLON <module_type> EQUAL <module_expr> |
                          <functor_arg> <module_binding_body>)>

<rec_module_bindings> ::= <xlist(<rec_module_binding>, <and_module_binding>)>

<rec_module_binding> ::= MODULE <ext> <attributes> REC <mkrhs(<module_name>)>
                         <module_binding_body> <post_item_attributes>

<and_module_binding> ::= AND <attributes> <mkrhs(<module_name>)>
                         <module_binding_body> <post_item_attributes>

<include_statement(thing)> ::= INCLUDE <ext> <attributes> thing
                               <post_item_attributes>

<module_type_declaration> ::= MODULE TYPE <ext> <attributes> <mkrhs(<ident>)>
                              [EQUAL <module_type>] <post_item_attributes>

<open_declaration> ::= OPEN <override_flag> <ext> <attributes> <module_expr>
                       <post_item_attributes>

<open_description> ::= OPEN <override_flag> <ext> <attributes>
                       <mkrhs(<mod_ext_longident>)> <post_item_attributes>

<open_dot_declaration> ::= <mkrhs(<mod_longident>)>

<module_type> ::= SIG <attributes> <signature> END
                | SIG <attributes> <signature> error
                | FUNCTOR <attributes> <functor_args> MINUSGREATER
                  <module_type>
                | MODULE TYPE OF <attributes> <module_expr>
                | LPAREN <module_type> RPAREN
                | LPAREN <module_type> error
                | <module_type> <attribute>
                | <mkmty(<mkrhs(<mty_longident>)> | <module_type>
                  MINUSGREATER <module_type> | <module_type> WITH
                  <separated_nonempty_llist(AND, <with_constraint>)> |
                  <extension>)>

<signature> ::= <extra_sig(<signature_element>*)>

<signature_element> ::= <text_sig_SEMISEMI>
                      | <text_sig(<signature_item>)>

<signature_item> ::= <item_extension> <post_item_attributes>
                   | <mksig(<floating_attribute>)>
                   | <wrap_mksig_ext(<value_description> |
                     <primitive_declaration> | <type_declarations> |
                     <type_subst_declarations> | <sig_type_extension> |
                     <sig_exception_declaration> | <module_declaration> |
                     <module_alias> | <module_subst> |
                     <rec_module_declarations> | <module_type_declaration> |
                     <module_type_subst> | <open_description> |
                     <include_statement(<module_type>)> |
                     <class_descriptions> | <class_type_declarations>)>

<module_declaration> ::= MODULE <ext> <attributes> <mkrhs(<module_name>)>
                         <module_declaration_body> <post_item_attributes>

<module_declaration_body> ::= COLON <module_type>
                            | <mkmty(<functor_arg>
                              <module_declaration_body>)>

<module_alias> ::= MODULE <ext> <attributes> <mkrhs(<module_name>)> EQUAL
                   <module_expr_alias> <post_item_attributes>

<module_expr_alias> ::= <mkrhs(<mod_longident>)>

<module_subst> ::= MODULE <ext> <attributes> <mkrhs(UIDENT)> COLONEQUAL
                   <mkrhs(<mod_ext_longident>)> <post_item_attributes>
                 | MODULE <ext> <attributes> <mkrhs(UIDENT)> COLONEQUAL error

<rec_module_declarations> ::= <xlist(<rec_module_declaration>,
                              <and_module_declaration>)>

<rec_module_declaration> ::= MODULE <ext> <attributes> REC
                             <mkrhs(<module_name>)> COLON <module_type>
                             <post_item_attributes>

<and_module_declaration> ::= AND <attributes> <mkrhs(<module_name>)> COLON
                             <module_type> <post_item_attributes>

<module_type_subst> ::= MODULE TYPE <ext> <attributes> <mkrhs(<ident>)>
                        COLONEQUAL <module_type> <post_item_attributes>

<class_declarations> ::= <xlist(<class_declaration>,
                         <and_class_declaration>)>

<class_declaration> ::= CLASS <ext> <attributes> <virtual_flag>
                        <formal_class_parameters> <mkrhs(LIDENT)>
                        <class_fun_binding> <post_item_attributes>

<and_class_declaration> ::= AND <attributes> <virtual_flag>
                            <formal_class_parameters> <mkrhs(LIDENT)>
                            <class_fun_binding> <post_item_attributes>

<class_fun_binding> ::= EQUAL <class_expr>
                      | <mkclass(COLON <class_type> EQUAL <class_expr> |
                        <labeled_simple_pattern> <class_fun_binding>)>

<formal_class_parameters> ::= <class_parameters(<type_parameter>)>

<class_expr> ::= <class_simple_expr>
               | FUN <attributes> <class_fun_def>
               | <let_bindings(<no_ext>)> IN <class_expr>
               | LET OPEN <override_flag> <attributes>
                 <mkrhs(<mod_longident>)> IN <class_expr>
               | <class_expr> <attribute>
               | <mkclass(<class_simple_expr>
                 <nonempty_llist(<labeled_simple_expr>)> | <extension>)>

<class_simple_expr> ::= LPAREN <class_expr> RPAREN
                      | LPAREN <class_expr> error
                      | <mkclass(<actual_class_parameters>
                        <mkrhs(<class_longident>)> | OBJECT <attributes>
                        <class_structure> error | LPAREN <class_expr> COLON
                        <class_type> RPAREN | LPAREN <class_expr> COLON
                        <class_type> error)>
                      | OBJECT <attributes> <class_structure> END

<class_fun_def> ::= <mkclass(<labeled_simple_pattern> MINUSGREATER
                    <class_expr> | <labeled_simple_pattern> <class_fun_def>)>

<class_structure> ::= <class_self_pattern> <extra_cstr(<class_fields>)>

<class_self_pattern> ::= LPAREN <pattern> RPAREN
                       | <mkpat(LPAREN <pattern> COLON <core_type> RPAREN)>
                       | epsilon

<class_fields> ::= <text_cstr(<class_field>)>*

<class_field> ::= INHERIT <override_flag> <attributes> <class_expr> [AS
                  <mkrhs(LIDENT)>] <post_item_attributes>
                | VAL <value> <post_item_attributes>
                | METHOD <method_> <post_item_attributes>
                | CONSTRAINT <attributes> <constrain_field>
                  <post_item_attributes>
                | INITIALIZER <attributes> <seq_expr> <post_item_attributes>
                | <item_extension> <post_item_attributes>
                | <mkcf(<floating_attribute>)>

<value> ::= <no_override_flag> <attributes> <virtual_with_mutable_flag>
            <mkrhs(<label>)> COLON <core_type>
          | <override_flag> <attributes> <mutable_flag> <mkrhs(<label>)>
            EQUAL <seq_expr>
          | <override_flag> <attributes> <mutable_flag> <mkrhs(<label>)>
            <type_constraint> EQUAL <seq_expr>

<method_> ::= <no_override_flag> <attributes> <virtual_with_private_flag>
              <mkrhs(<label>)> COLON <poly_type>
            | <override_flag> <attributes> <private_flag> <mkrhs(<label>)>
              <strict_binding>
            | <override_flag> <attributes> <private_flag> <mkrhs(<label>)>
              COLON <poly_type> EQUAL <seq_expr>
            | <override_flag> <attributes> <private_flag> <mkrhs(<label>)>
              COLON TYPE <lident_list> DOT <core_type> EQUAL <seq_expr>

<class_type> ::= <class_signature>
               | <mkcty(<arg_label> <tuple_type> MINUSGREATER <class_type>)>

<class_signature> ::= <mkcty(<actual_class_parameters>
                      <mkrhs(<clty_longident>)> | <extension>)>
                    | OBJECT <attributes> <class_sig_body> END
                    | OBJECT <attributes> <class_sig_body> error
                    | <class_signature> <attribute>
                    | LET OPEN <override_flag> <attributes>
                      <mkrhs(<mod_longident>)> IN <class_signature>

<class_parameters(parameter)> ::= [LBRACKET <separated_nonempty_llist(COMMA,
                                  parameter)> RBRACKET]

<actual_class_parameters> ::= <class_parameters(<core_type>)>

<class_sig_body> ::= <class_self_type> <extra_csig(<class_sig_fields>)>

<class_self_type> ::= LPAREN <core_type> RPAREN
                    | <mktyp(epsilon)>

<class_sig_fields> ::= <text_csig(<class_sig_field>)>*

<class_sig_field> ::= INHERIT <attributes> <class_signature>
                      <post_item_attributes>
                    | VAL <attributes> <value_type> <post_item_attributes>
                    | METHOD <attributes> <private_virtual_flags>
                      <mkrhs(<label>)> COLON <poly_type>
                      <post_item_attributes>
                    | CONSTRAINT <attributes> <constrain_field>
                      <post_item_attributes>
                    | <item_extension> <post_item_attributes>
                    | <mkctf(<floating_attribute>)>

<value_type> ::= <mutable_virtual_flags> <mkrhs(<label>)> COLON <core_type>

<constrain> ::= <core_type> EQUAL <core_type>

<constrain_field> ::= <core_type> EQUAL <core_type>

<class_descriptions> ::= <xlist(<class_description>,
                         <and_class_description>)>

<class_description> ::= CLASS <ext> <attributes> <virtual_flag>
                        <formal_class_parameters> <mkrhs(LIDENT)> COLON
                        <class_type> <post_item_attributes>

<and_class_description> ::= AND <attributes> <virtual_flag>
                            <formal_class_parameters> <mkrhs(LIDENT)> COLON
                            <class_type> <post_item_attributes>

<class_type_declarations> ::= <xlist(<class_type_declaration>,
                              <and_class_type_declaration>)>

<class_type_declaration> ::= CLASS TYPE <ext> <attributes> <virtual_flag>
                             <formal_class_parameters> <mkrhs(LIDENT)> EQUAL
                             <class_signature> <post_item_attributes>

<and_class_type_declaration> ::= AND <attributes> <virtual_flag>
                                 <formal_class_parameters> <mkrhs(LIDENT)>
                                 EQUAL <class_signature>
                                 <post_item_attributes>

<seq_expr> ::= <expr>
             | <expr> SEMI
             | <mkexp(<expr> SEMI <seq_expr>)>
             | <expr> SEMI PERCENT <attr_id> <seq_expr>

<labeled_simple_pattern> ::= QUESTION LPAREN <label_let_pattern>
                             <opt_default> RPAREN
                           | QUESTION <label_var>
                           | OPTLABEL LPAREN <let_pattern> <opt_default>
                             RPAREN
                           | OPTLABEL <pattern_var>
                           | TILDE LPAREN <label_let_pattern> RPAREN
                           | TILDE <label_var>
                           | LABEL <simple_pattern>
                           | <simple_pattern>

<pattern_var> ::= <mkpat(<mkrhs(LIDENT)> | UNDERSCORE)>

<opt_default> ::= [EQUAL <seq_expr>]

<label_let_pattern> ::= <label_var>
                      | <label_var> COLON <core_type>

<label_var> ::= <mkrhs(LIDENT)>

<let_pattern> ::= <pattern>
                | <mkpat(<pattern> COLON <core_type>)>

<indexop_expr(dot, index, right)> ::= <simple_expr> dot LPAREN index RPAREN
                                      right
                                    | <simple_expr> dot LBRACE index RBRACE
                                      right
                                    | <simple_expr> dot LBRACKET index
                                      RBRACKET right

<indexop_error(dot, index)> ::= <simple_expr> dot LPAREN index error
                              | <simple_expr> dot LBRACE index error
                              | <simple_expr> dot LBRACKET index error

<qualified_dotop> ::= [DOT <mod_longident>] DOTOP

<expr> ::= <simple_expr>
         | <expr_attrs>
         | <mkexp(<expr_>)>
         | <let_bindings(<ext>)> IN <seq_expr>
         | <mkrhs(LETOP)> <letop_bindings> IN <seq_expr>
         | <expr> COLONCOLON <expr>
         | <mkrhs(<label>)> LESSMINUS <expr>
         | <simple_expr> DOT <mkrhs(<label_longident>)> LESSMINUS <expr>
         | <indexop_expr(DOT, <seq_expr>, LESSMINUS <expr>)>
         | <indexop_expr(<qualified_dotop>, <expr_semi_list>, LESSMINUS
           <expr>)>
         | <expr> <attribute>
         | UNDERSCORE

<expr_attrs> ::= LET MODULE <ext_attributes> <mkrhs(<module_name>)>
                 <module_binding_body> IN <seq_expr>
               | LET EXCEPTION <ext_attributes> <let_exception_declaration>
                 IN <seq_expr>
               | LET OPEN <override_flag> <ext_attributes> <module_expr> IN
                 <seq_expr>
               | FUNCTION <ext_attributes> <match_cases>
               | FUN <ext_attributes> <labeled_simple_pattern> <fun_def>
               | FUN <ext_attributes> LPAREN TYPE <lident_list> RPAREN
                 <fun_def>
               | MATCH <ext_attributes> <seq_expr> WITH <match_cases>
               | TRY <ext_attributes> <seq_expr> WITH <match_cases>
               | TRY <ext_attributes> <seq_expr> WITH error
               | IF <ext_attributes> <seq_expr> THEN <expr> ELSE <expr>
               | IF <ext_attributes> <seq_expr> THEN <expr>
               | WHILE <ext_attributes> <seq_expr> <do_done_expr>
               | FOR <ext_attributes> <pattern> EQUAL <seq_expr>
                 <direction_flag> <seq_expr> <do_done_expr>
               | ASSERT <ext_attributes> <simple_expr>
               | LAZY <ext_attributes> <simple_expr>

<do_done_expr> ::= DO <seq_expr> DONE
                 | DO <seq_expr> error

<expr_> ::= <simple_expr> <nonempty_llist(<labeled_simple_expr>)>
          | <expr_comma_list>
          | <mkrhs(<constr_longident>)> <simple_expr>
          | <name_tag> <simple_expr>
          | <expr> <op(<infix_operator>)> <expr>
          | <subtractive> <expr>
          | <additive> <expr>

<simple_expr> ::= LPAREN <seq_expr> RPAREN
                | LPAREN <seq_expr> error
                | LPAREN <seq_expr> <type_constraint> RPAREN
                | <indexop_expr(DOT, <seq_expr>, epsilon)>
                | <indexop_expr(<qualified_dotop>, <expr_semi_list>,
                  epsilon)>
                | <indexop_error(DOT, <seq_expr>)>
                | <indexop_error(<qualified_dotop>, <expr_semi_list>)>
                | <simple_expr_attrs>
                | <mkexp(<simple_expr_>)>

<simple_expr_attrs> ::= BEGIN <ext> <attributes> <seq_expr> END
                      | BEGIN <ext_attributes> END
                      | BEGIN <ext_attributes> <seq_expr> error
                      | NEW <ext_attributes> <mkrhs(<class_longident>)>
                      | LPAREN MODULE <ext_attributes> <module_expr> RPAREN
                      | LPAREN MODULE <ext_attributes> <module_expr> COLON
                        <package_type> RPAREN
                      | LPAREN MODULE <ext_attributes> <module_expr> COLON
                        error
                      | OBJECT <ext_attributes> <class_structure> END
                      | OBJECT <ext_attributes> <class_structure> error

<simple_expr_> ::= <mkrhs(<val_longident>)>
                 | <constant>
                 | <mkrhs(<constr_longident>)>
                 | <name_tag>
                 | <op(PREFIXOP)> <simple_expr>
                 | <op(BANG)> <simple_expr>
                 | LBRACELESS <object_expr_content> GREATERRBRACE
                 | LBRACELESS <object_expr_content> error
                 | LBRACELESS GREATERRBRACE
                 | <simple_expr> DOT <mkrhs(<label_longident>)>
                 | <open_dot_declaration> DOT LPAREN <seq_expr> RPAREN
                 | <open_dot_declaration> DOT LBRACELESS
                   <object_expr_content> GREATERRBRACE
                 | <mod_longident> DOT LBRACELESS <object_expr_content> error
                 | <simple_expr> HASH <mkrhs(<label>)>
                 | <simple_expr> <op(HASHOP)> <simple_expr>
                 | <extension>
                 | <open_dot_declaration> DOT <mkrhs(LPAREN RPAREN)>
                 | <mod_longident> DOT LPAREN <seq_expr> error
                 | LBRACE <record_expr_content> RBRACE
                 | LBRACE <record_expr_content> error
                 | <open_dot_declaration> DOT LBRACE <record_expr_content>
                   RBRACE
                 | <mod_longident> DOT LBRACE <record_expr_content> error
                 | LBRACKETBAR <expr_semi_list> BARRBRACKET
                 | LBRACKETBAR <expr_semi_list> error
                 | LBRACKETBAR BARRBRACKET
                 | <open_dot_declaration> DOT LBRACKETBAR <expr_semi_list>
                   BARRBRACKET
                 | <open_dot_declaration> DOT LBRACKETBAR BARRBRACKET
                 | <mod_longident> DOT LBRACKETBAR <expr_semi_list> error
                 | LBRACKET <expr_semi_list> RBRACKET
                 | LBRACKET <expr_semi_list> error
                 | <open_dot_declaration> DOT LBRACKET <expr_semi_list>
                   RBRACKET
                 | <open_dot_declaration> DOT <mkrhs(LBRACKET RBRACKET)>
                 | <mod_longident> DOT LBRACKET <expr_semi_list> error
                 | <open_dot_declaration> DOT LPAREN MODULE <ext_attributes>
                   <module_expr> COLON <package_type> RPAREN
                 | <mod_longident> DOT LPAREN MODULE <ext_attributes>
                   <module_expr> COLON error

<labeled_simple_expr> ::= <simple_expr>
                        | LABEL <simple_expr>
                        | TILDE LIDENT
                        | TILDE LPAREN LIDENT <type_constraint> RPAREN
                        | QUESTION LIDENT
                        | OPTLABEL <simple_expr>

<lident_list> ::= <mkrhs(LIDENT)>+

<let_ident> ::= <val_ident>

<let_binding_body_no_punning> ::= <let_ident> <strict_binding>
                                | <let_ident> <type_constraint> EQUAL
                                  <seq_expr>
                                | <let_ident> COLON <poly(<core_type>)> EQUAL
                                  <seq_expr>
                                | <let_ident> COLON TYPE <lident_list> DOT
                                  <core_type> EQUAL <seq_expr>
                                | <pattern_no_exn> EQUAL <seq_expr>
                                | <simple_pattern_not_ident> COLON
                                  <core_type> EQUAL <seq_expr>

<let_binding_body> ::= <let_binding_body_no_punning>
                     | <val_ident>

<let_bindings(EXT)> ::= <let_binding(EXT)>
                      | <let_bindings(EXT)> <and_let_binding>

<let_binding(EXT)> ::= LET EXT <attributes> <rec_flag> <let_binding_body>
                       <post_item_attributes>

<and_let_binding> ::= AND <attributes> <let_binding_body>
                      <post_item_attributes>

<letop_binding_body> ::= <let_ident> <strict_binding>
                       | <val_ident>
                       | <simple_pattern> COLON <core_type> EQUAL <seq_expr>
                       | <pattern_no_exn> EQUAL <seq_expr>

<letop_bindings> ::= <letop_binding_body> (<mkrhs(ANDOP)>
                     <letop_binding_body>)*

<fun_binding> ::= <strict_binding>
                | <type_constraint> EQUAL <seq_expr>

<strict_binding> ::= EQUAL <seq_expr>
                   | <labeled_simple_pattern> <fun_binding>
                   | LPAREN TYPE <lident_list> RPAREN <fun_binding>

<match_cases> ::= <preceded_or_separated_nonempty_llist(BAR, <match_case>)>

<match_case> ::= <pattern> MINUSGREATER <seq_expr>
               | <pattern> WHEN <seq_expr> MINUSGREATER <seq_expr>
               | <pattern> MINUSGREATER DOT

<fun_def> ::= MINUSGREATER <seq_expr>
            | <mkexp(COLON <atomic_type> MINUSGREATER <seq_expr>)>
            | <labeled_simple_pattern> <fun_def>
            | LPAREN TYPE <lident_list> RPAREN <fun_def>

<expr_comma_list> ::= <separated_nontrivial_llist(COMMA, <expr>)>

<record_expr_content> ::= [<simple_expr> WITH]
                          <separated_or_terminated_nonempty_list(SEMI,
                          <record_expr_field>)>

<record_expr_field> ::= <mkrhs(<label_longident>)> [<type_constraint>] [EQUAL
                        <expr>]

<object_expr_content> ::= <separated_or_terminated_nonempty_list(SEMI,
                          <object_expr_field>)>

<object_expr_field> ::= <mkrhs(<label>)> [EQUAL <expr>]

<expr_semi_list> ::= <separated_or_terminated_nonempty_list(SEMI, <expr>)>

<type_constraint> ::= COLON <core_type>
                    | COLON <core_type> COLONGREATER <core_type>
                    | COLONGREATER <core_type>
                    | COLON error
                    | COLONGREATER error

<pattern> ::= <pattern_(<pattern>)>
            | EXCEPTION <ext_attributes> <pattern>

<pattern_no_exn> ::= <pattern_(<pattern_no_exn>)>

<pattern_(self)> ::= self COLONCOLON <pattern>
                   | self <attribute>
                   | <pattern_gen>
                   | <mkpat(self AS <mkrhs(<val_ident>)> | self AS error |
                     <pattern_comma_list(self)> | self COLONCOLON error |
                     self BAR <pattern> | self BAR error)>

<pattern_gen> ::= <simple_pattern>
                | <mkpat(<mkrhs(<constr_longident>)> <pattern> |
                  <mkrhs(<constr_longident>)> LPAREN TYPE <lident_list>
                  RPAREN <simple_pattern> | <name_tag> <pattern>)>
                | LAZY <ext_attributes> <simple_pattern>

<simple_pattern> ::= <mkpat(<mkrhs(<val_ident>)>)>
                   | <simple_pattern_not_ident>

<simple_pattern_not_ident> ::= LPAREN <pattern> RPAREN
                             | <simple_delimited_pattern>
                             | LPAREN MODULE <ext_attributes>
                               <mkrhs(<module_name>)> RPAREN
                             | LPAREN MODULE <ext_attributes>
                               <mkrhs(<module_name>)> COLON <package_type>
                               RPAREN
                             | <mkpat(<simple_pattern_not_ident_>)>

<simple_pattern_not_ident_> ::= UNDERSCORE
                              | <signed_constant>
                              | <signed_constant> DOTDOT <signed_constant>
                              | <mkrhs(<constr_longident>)>
                              | <name_tag>
                              | HASH <mkrhs(<type_longident>)>
                              | <mkrhs(<mod_longident>)> DOT
                                <simple_delimited_pattern>
                              | <mkrhs(<mod_longident>)> DOT <mkrhs(LBRACKET
                                RBRACKET)>
                              | <mkrhs(<mod_longident>)> DOT <mkrhs(LPAREN
                                RPAREN)>
                              | <mkrhs(<mod_longident>)> DOT LPAREN <pattern>
                                RPAREN
                              | <mod_longident> DOT LPAREN <pattern> error
                              | <mod_longident> DOT LPAREN error
                              | LPAREN <pattern> error
                              | LPAREN <pattern> COLON <core_type> RPAREN
                              | LPAREN <pattern> COLON <core_type> error
                              | LPAREN <pattern> COLON error
                              | LPAREN MODULE <ext_attributes> <module_name>
                                COLON <package_type> error
                              | <extension>

<simple_delimited_pattern> ::= <mkpat(LBRACE <record_pat_content> RBRACE |
                               LBRACE <record_pat_content> error | LBRACKET
                               <pattern_semi_list> RBRACKET | LBRACKET
                               <pattern_semi_list> error | LBRACKETBAR
                               <pattern_semi_list> BARRBRACKET | LBRACKETBAR
                               BARRBRACKET | LBRACKETBAR <pattern_semi_list>
                               error)>

<pattern_comma_list(self)> ::= <pattern_comma_list(self)> COMMA <pattern>
                             | self COMMA <pattern>
                             | self COMMA error

<pattern_semi_list> ::= <separated_or_terminated_nonempty_list(SEMI,
                        <pattern>)>

<record_pat_content> ::= <listx(SEMI, <record_pat_field>, UNDERSCORE)>

<record_pat_field> ::= <mkrhs(<label_longident>)> [COLON <core_type>] [EQUAL
                       <pattern>]

<value_description> ::= VAL <ext> <attributes> <mkrhs(<val_ident>)> COLON
                        <possibly_poly(<core_type>)> <post_item_attributes>

<primitive_declaration> ::= EXTERNAL <ext> <attributes> <mkrhs(<val_ident>)>
                            COLON <possibly_poly(<core_type>)> EQUAL
                            <raw_string>+ <post_item_attributes>

<type_declarations> ::= <generic_type_declarations(<nonrec_flag>,
                        <type_kind>)>

<type_subst_declarations> ::= <generic_type_declarations(<no_nonrec_flag>,
                              <type_subst_kind>)>

<generic_type_declarations(flag, kind)> ::= <xlist(<generic_type_declaration(flag,
                                            kind)>,
                                            <generic_and_type_declaration(kind)>)>

<generic_type_declaration(flag, kind)> ::= TYPE <ext> <attributes> flag
                                           <type_parameters> <mkrhs(LIDENT)>
                                           kind <constraints>
                                           <post_item_attributes>

<generic_and_type_declaration(kind)> ::= AND <attributes> <type_parameters>
                                         <mkrhs(LIDENT)> kind <constraints>
                                         <post_item_attributes>

<constraints> ::= <llist(CONSTRAINT <constrain>)>

<nonempty_type_kind> ::= <inline_private_flag> <core_type>
                       | <type_synonym> <inline_private_flag>
                         <constructor_declarations>
                       | <type_synonym> <inline_private_flag> DOTDOT
                       | <type_synonym> <inline_private_flag> LBRACE
                         <label_declarations> RBRACE

<type_synonym> ::= [<core_type> EQUAL]

<type_kind> ::= [EQUAL <nonempty_type_kind>]

<type_subst_kind> ::= COLONEQUAL <nonempty_type_kind>

<type_parameters> ::= epsilon
                    | <type_parameter>
                    | LPAREN <separated_nonempty_llist(COMMA,
                      <type_parameter>)> RPAREN

<type_parameter> ::= <type_variance> <type_variable>

<type_variable> ::= <mktyp(QUOTE <ident> | UNDERSCORE)>

<type_variance> ::= epsilon
                  | PLUS
                  | MINUS
                  | BANG
                  | PLUS BANG
                  | BANG PLUS
                  | MINUS BANG
                  | BANG MINUS
                  | INFIXOP2
                  | PREFIXOP

<constructor_declarations> ::= BAR
                             | <bar_llist(<constructor_declaration>)>

<generic_constructor_declaration(opening)> ::= opening
                                               <mkrhs(<constr_ident>)>
                                               <generalized_constructor_arguments>
                                               <attributes>

<constructor_declaration(opening)> ::= <generic_constructor_declaration(opening)>

<str_exception_declaration> ::= <sig_exception_declaration>
                              | EXCEPTION <ext> <attributes>
                                <mkrhs(<constr_ident>)> EQUAL
                                <mkrhs(<constr_longident>)> <attributes>
                                <post_item_attributes>

<sig_exception_declaration> ::= EXCEPTION <ext> <attributes>
                                <mkrhs(<constr_ident>)>
                                <generalized_constructor_arguments>
                                <attributes> <post_item_attributes>

<let_exception_declaration> ::= <mkrhs(<constr_ident>)>
                                <generalized_constructor_arguments>
                                <attributes>

<generalized_constructor_arguments> ::= epsilon
                                      | OF <constructor_arguments>
                                      | COLON <constructor_arguments>
                                        MINUSGREATER <atomic_type>
                                      | COLON <typevar_list> DOT
                                        <constructor_arguments> MINUSGREATER
                                        <atomic_type>
                                      | COLON <atomic_type>
                                      | COLON <typevar_list> DOT
                                        <atomic_type>

<constructor_arguments> ::= <inline_separated_nonempty_llist(STAR,
                            <atomic_type>)>
                          | LBRACE <label_declarations> RBRACE

<label_declarations> ::= <label_declaration>
                       | <label_declaration_semi>
                       | <label_declaration_semi> <label_declarations>

<label_declaration> ::= <mutable_flag> <mkrhs(<label>)> COLON
                        <poly_type_no_attr> <attributes>

<label_declaration_semi> ::= <mutable_flag> <mkrhs(<label>)> COLON
                             <poly_type_no_attr> <attributes> SEMI
                             <attributes>

<str_type_extension> ::= <type_extension(<extension_constructor>)>

<sig_type_extension> ::= <type_extension(<extension_constructor_declaration>)>

<type_extension(declaration)> ::= TYPE <ext> <attributes> <no_nonrec_flag>
                                  <type_parameters> <mkrhs(<type_longident>)>
                                  PLUSEQ <private_flag>
                                  <bar_llist(declaration)>
                                  <post_item_attributes>

<extension_constructor(opening)> ::= <extension_constructor_declaration(opening)>
                                   | <extension_constructor_rebind(opening)>

<extension_constructor_declaration(opening)> ::= <generic_constructor_declaration(opening)>

<extension_constructor_rebind(opening)> ::= opening <mkrhs(<constr_ident>)>
                                            EQUAL <mkrhs(<constr_longident>)>
                                            <attributes>

<with_constraint> ::= TYPE <type_parameters> <mkrhs(<label_longident>)>
                      <with_type_binder> <core_type_no_attr> <constraints>
                    | TYPE <type_parameters> <mkrhs(<label_longident>)>
                      COLONEQUAL <core_type_no_attr>
                    | MODULE <mkrhs(<mod_longident>)> EQUAL
                      <mkrhs(<mod_ext_longident>)>
                    | MODULE <mkrhs(<mod_longident>)> COLONEQUAL
                      <mkrhs(<mod_ext_longident>)>
                    | MODULE TYPE <mkrhs(<mty_longident>)> EQUAL
                      <module_type>
                    | MODULE TYPE <mkrhs(<mty_longident>)> COLONEQUAL
                      <module_type>

<with_type_binder> ::= EQUAL
                     | EQUAL PRIVATE

<typevar> ::= QUOTE <mkrhs(<ident>)>

<typevar_list> ::= <nonempty_llist(<typevar>)>

<poly(X)> ::= <typevar_list> DOT X

<possibly_poly(X)> ::= X
                     | <mktyp(<poly(X)>)>

<poly_type> ::= <possibly_poly(<core_type>)>

<poly_type_no_attr> ::= <possibly_poly(<core_type_no_attr>)>

<core_type> ::= <core_type_no_attr>
              | <core_type> <attribute>

<core_type_no_attr> ::= <alias_type>

<alias_type> ::= <function_type>
               | <mktyp(<alias_type> AS QUOTE <ident>)>

<function_type> ::= <tuple_type>
                  | <mktyp(<arg_label> <extra_rhs(<tuple_type>)> MINUSGREATER
                    <function_type>)>

<arg_label> ::= <optlabel>
              | LIDENT COLON
              | epsilon

<tuple_type> ::= <atomic_type>
               | <mktyp(<separated_nontrivial_llist(STAR, <atomic_type>)>)>

<atomic_type> ::= LPAREN <core_type> RPAREN
                | LPAREN MODULE <ext_attributes> <package_type> RPAREN
                | <mktyp(QUOTE <ident> | UNDERSCORE |
                  <actual_type_parameters> <mkrhs(<type_longident>)> | LESS
                  <meth_list> GREATER | LESS GREATER |
                  <actual_type_parameters> HASH <mkrhs(<clty_longident>)> |
                  LBRACKET <tag_field> RBRACKET | LBRACKET BAR
                  <row_field_list> RBRACKET | LBRACKET <row_field> BAR
                  <row_field_list> RBRACKET | LBRACKETGREATER [BAR]
                  <row_field_list> RBRACKET | LBRACKETGREATER RBRACKET |
                  LBRACKETLESS [BAR] <row_field_list> RBRACKET | LBRACKETLESS
                  [BAR] <row_field_list> GREATER <name_tag_list> RBRACKET |
                  <extension>)>

<actual_type_parameters> ::= epsilon
                           | <atomic_type>
                           | LPAREN <separated_nontrivial_llist(COMMA,
                             <core_type>)> RPAREN

<package_type> ::= <module_type>

<row_field_list> ::= <separated_nonempty_llist(BAR, <row_field>)>

<row_field> ::= <tag_field>
              | <core_type>

<tag_field> ::= <mkrhs(<name_tag>)> OF <opt_ampersand> <amper_type_list>
                <attributes>
              | <mkrhs(<name_tag>)> <attributes>

<opt_ampersand> ::= [AMPERSAND]

<amper_type_list> ::= <separated_nonempty_llist(AMPERSAND,
                      <core_type_no_attr>)>

<name_tag_list> ::= <nonempty_llist(<name_tag>)>

<meth_list> ::= <field_semi> <meth_list>
              | <inherit_field> SEMI <meth_list>
              | <field_semi>
              | <inherit_field> SEMI
              | <field>
              | <inherit_field>
              | DOTDOT

<field> ::= <mkrhs(<label>)> COLON <poly_type_no_attr> <attributes>

<field_semi> ::= <mkrhs(<label>)> COLON <poly_type_no_attr> <attributes> SEMI
                 <attributes>

<inherit_field> ::= <atomic_type>

<label> ::= LIDENT

<constant> ::= INT
             | CHAR
             | STRING
             | FLOAT

<signed_constant> ::= <constant>
                    | MINUS INT
                    | MINUS FLOAT
                    | PLUS INT
                    | PLUS FLOAT

<ident> ::= UIDENT
          | LIDENT

<val_extra_ident> ::= LPAREN <operator> RPAREN
                    | LPAREN <operator> error
                    | LPAREN error
                    | LPAREN MODULE error

<val_ident> ::= LIDENT
              | <val_extra_ident>

<operator> ::= PREFIXOP
             | LETOP
             | ANDOP
             | DOTOP LPAREN <index_mod> RPAREN
             | DOTOP LPAREN <index_mod> RPAREN LESSMINUS
             | DOTOP LBRACKET <index_mod> RBRACKET
             | DOTOP LBRACKET <index_mod> RBRACKET LESSMINUS
             | DOTOP LBRACE <index_mod> RBRACE
             | DOTOP LBRACE <index_mod> RBRACE LESSMINUS
             | HASHOP
             | BANG
             | <infix_operator>

<infix_operator> ::= INFIXOP0
                   | INFIXOP1
                   | INFIXOP2
                   | INFIXOP3
                   | INFIXOP4
                   | PLUS
                   | PLUSDOT
                   | PLUSEQ
                   | MINUS
                   | MINUSDOT
                   | STAR
                   | PERCENT
                   | EQUAL
                   | LESS
                   | GREATER
                   | OR
                   | BARBAR
                   | AMPERSAND
                   | AMPERAMPER
                   | COLONEQUAL

<index_mod> ::= [SEMI DOTDOT]

<constr_extra_ident> ::= LPAREN COLONCOLON RPAREN

<constr_extra_nonprefix_ident> ::= LBRACKET RBRACKET
                                 | LPAREN RPAREN
                                 | FALSE
                                 | TRUE

<constr_ident> ::= UIDENT
                 | <constr_extra_ident>
                 | <constr_extra_nonprefix_ident>

<constr_longident> ::= <mod_longident>
                     | <mod_longident> DOT <constr_extra_ident>
                     | <constr_extra_ident>
                     | <constr_extra_nonprefix_ident>

<mk_longident(prefix, final)> ::= final
                                | prefix DOT final

<val_longident> ::= <mk_longident(<mod_longident>, <val_ident>)>

<label_longident> ::= <mk_longident(<mod_longident>, LIDENT)>

<type_longident> ::= <mk_longident(<mod_ext_longident>, LIDENT)>

<mod_longident> ::= <mk_longident(<mod_longident>, UIDENT)>

<mod_ext_longident> ::= <mk_longident(<mod_ext_longident>, UIDENT)>
                      | <mod_ext_longident> LPAREN <mod_ext_longident> RPAREN
                      | <mod_ext_longident> LPAREN error

<mty_longident> ::= <mk_longident(<mod_ext_longident>, <ident>)>

<clty_longident> ::= <mk_longident(<mod_ext_longident>, LIDENT)>

<class_longident> ::= <mk_longident(<mod_longident>, LIDENT)>

<any_longident> ::= <mk_longident(<mod_ext_longident>, <ident> |
                    <constr_extra_ident> | <val_extra_ident>)>
                  | <constr_extra_nonprefix_ident>

<toplevel_directive> ::= HASH <mkrhs(<ident>)>
                         [<mk_directive_arg(<toplevel_directive_argument>)>]

<toplevel_directive_argument> ::= STRING
                                | INT
                                | <val_longident>
                                | <mod_longident>
                                | FALSE
                                | TRUE

<epsilon> ::= epsilon

<raw_string> ::= STRING

<name_tag> ::= BACKQUOTE <ident>

<rec_flag> ::= [REC]

<nonrec_flag> ::= [NONREC]

<no_nonrec_flag> ::= [NONREC]

<direction_flag> ::= TO
                   | DOWNTO

<private_flag> ::= <inline_private_flag>

<inline_private_flag> ::= [PRIVATE]

<mutable_flag> ::= [MUTABLE]

<virtual_flag> ::= [VIRTUAL]

<mutable_virtual_flags> ::= epsilon
                          | MUTABLE
                          | VIRTUAL
                          | MUTABLE VIRTUAL
                          | VIRTUAL MUTABLE

<private_virtual_flags> ::= epsilon
                          | PRIVATE
                          | VIRTUAL
                          | PRIVATE VIRTUAL
                          | VIRTUAL PRIVATE

<virtual_with_mutable_flag> ::= VIRTUAL
                              | MUTABLE VIRTUAL
                              | VIRTUAL MUTABLE

<virtual_with_private_flag> ::= VIRTUAL
                              | PRIVATE VIRTUAL
                              | VIRTUAL PRIVATE

<no_override_flag> ::= epsilon

<override_flag> ::= [BANG]

<subtractive> ::= MINUS
                | MINUSDOT

<additive> ::= PLUS
             | PLUSDOT

<optlabel> ::= OPTLABEL
             | QUESTION LIDENT COLON

<single_attr_id> ::= LIDENT
                   | UIDENT
                   | AND
                   | AS
                   | ASSERT
                   | BEGIN
                   | CLASS
                   | CONSTRAINT
                   | DO
                   | DONE
                   | DOWNTO
                   | ELSE
                   | END
                   | EXCEPTION
                   | EXTERNAL
                   | FALSE
                   | FOR
                   | FUN
                   | FUNCTION
                   | FUNCTOR
                   | IF
                   | IN
                   | INCLUDE
                   | INHERIT
                   | INITIALIZER
                   | LAZY
                   | LET
                   | MATCH
                   | METHOD
                   | MODULE
                   | MUTABLE
                   | NEW
                   | NONREC
                   | OBJECT
                   | OF
                   | OPEN
                   | OR
                   | PRIVATE
                   | REC
                   | SIG
                   | STRUCT
                   | THEN
                   | TO
                   | TRUE
                   | TRY
                   | TYPE
                   | VAL
                   | VIRTUAL
                   | WHEN
                   | WHILE
                   | WITH

<attr_id> ::= <mkloc(<single_attr_id> | <single_attr_id> DOT <attr_id>)>

<attribute> ::= LBRACKETAT <attr_id> <payload> RBRACKET

<post_item_attribute> ::= LBRACKETATAT <attr_id> <payload> RBRACKET

<floating_attribute> ::= LBRACKETATATAT <attr_id> <payload> RBRACKET

<post_item_attributes> ::= <post_item_attribute>*

<attributes> ::= <attribute>*

<ext> ::= [PERCENT <attr_id>]

<no_ext> ::= [PERCENT <attr_id>]

<ext_attributes> ::= <ext> <attributes>

<extension> ::= LBRACKETPERCENT <attr_id> <payload> RBRACKET
              | QUOTED_STRING_EXPR

<item_extension> ::= LBRACKETPERCENTPERCENT <attr_id> <payload> RBRACKET
                   | QUOTED_STRING_ITEM

<payload> ::= <structure>
            | COLON <signature>
            | COLON <core_type>
            | QUESTION <pattern>
            | QUESTION <pattern> WHEN <seq_expr>


