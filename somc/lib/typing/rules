# notes

type scheme:
  scheme 'a . 'b means that type 'b
  exists for all instances of type 'a.
  for example, 'a . 'a -> () is the
  type for the 'ignore' function.

generalize:
  generalization takes a set of
  constraints C, a static environment
  env and a variable x with inferred
  type (scheme) t. it unifies/solves C
  and applies the resulting substitution
  to env and t, yielding env1 and t1.
  then it generalizes t1 to a type scheme
  s (including type variables in t1, but
  not including type variables that are
  also in env1 as they are constrained by
  outside code). it then returns env1 and
  x bound to type scheme s.

  pseudocode:
  generalize(C, env, x : t):
    unify C -> subst
    subst(env, t) -> env1, t1
    t1 -> (type scheme) s
      e.g. 'a -> 'b to 'a 'b . 'a -> 'b
    return env1, x : s

instantiate:
  instantiating a type scheme creates
  a new type from that scheme when
  given "parameter types" for that
  scheme. for example, instantiating
  scheme 'a . 'a -> int with type
  bool would create bool -> int

# expressions

## grouping

env ⊢ '(' e ')' : t ⊣ C
  if env ⊢ e : t ⊣ C

## binding

env ⊢ x '=' e1 '=>' e2 : t2 ⊣ {C1, C2}
  if env ⊢ e1 : t1 ⊣ C1
  and generalize(C1, env, x : t1) ⊢ e2 : t2 ⊣ C2

## lambda

env ⊢ '\' x '=>' e : 't1 -> t2 ⊣ C
  if fresh 't1
  and {env, x : 't1} ⊢ e : t2 ⊣ C

## sequence

env ⊢ e1 ';' e2 : t ⊣ C
  if env ⊢ e2 : t ⊣ C

## if-expressions

env ⊢ e1 '?' e2 ':' e3 : 't ⊣ {C1, C2, C3, t1 = bool, 't = t2, 't = t3}
  if fresh 't
  and env ⊢ e1 : t1 ⊣ C1
  and env ⊢ e2 : t2 ⊣ C2
  and env ⊢ e3 : t3 ⊣ C3

## application

env ⊢ e1 e2 : 't ⊣ {C1, C2, t1 = t2 -> 't}
  if fresh 't
  and env ⊢ e1 : t1 ⊣ C1
  and env ⊢ e2 : t2 ⊣ C2

## tuple

env ⊢ e1 ';' e2 : t1; t2 ⊣ {C1, C2}
  if env ⊢ e1 : t1 ⊣ C1
  and env ⊢ e2 : t2 ⊣ C2

## construct

depends on definition

## literal

env ⊢ b : Bool ⊣ {}
env ⊢ i : Int ⊣ {}
env ⊢ f : Float ⊣ {}
env ⊢ c : Char ⊣ {}
env ⊢ s : Str ⊣ {}
env ⊢ n : Unit ⊣ {}

## identifier

env ⊢ n : instantiate(env(n)) ⊣ {}
