%YAML 1.2

---

name: Idk
file_extensions: [idk]
fileTypes: [idk]
scope: source.idk

variables:
  ident: '[A-Za-z_][A-Za-z_0-9]*''*'

  # numbers
  decimal: '\b[0-9]+(?:\.[0-9]+)?\b'
  binary: '\b0b[0-1]+\b'
  octal: '\b0c[0-7]+\b'
  hexadecimal: '\b0x[0-9a-fA-F]+\b'
  number: '{{decimal}}|{{binary}}|{{octal}}|{{hexadecimal}}'

  # types
  basetype: int|flt|bln|chr|str|nll
  modifier: \[\s*(?:{{number}})?\s*\]
  type: \b(?:{{basetype}})(?:{{modifier}})*\b

  # properties
  property: (?:no_redef|warn_redef|public|private)

contexts:
  prototype:
    #
    - include: comments

  main:
    # The main context is the initial starting point of our syntax.
    # Include other contexts from here (or specify them directly).
    - include: comment
    - include: property
    - include: application
    - include: section
    - include: structdef
    - include: expression
    - include: invalid

  type:
    - match: \b{{type}}\b
      scope: storage.type.idk
      pop: true

  # STATEMENTS

  property:
    - match: \!\!?\s*{{property}}
      scope: punctuation.definition.annotation.idk

  application:
    - match: \#
      scope: keyword.import.idk
      push:
        - match: (?:({{ident}})\s*(\.)\s*)*({{ident}})
          scope: entity.name.namespace.idk
          # captures:
            # 1: entity.name.namespace.idk
            # 2: punctuation.accessor.idk
            # 3: entity.name.namespace.idk
          pop: true
        - include: invalid

  section:
    - match: ({{ident}})\s*(\[)
      captures:
        1: entity.name.namespace.idk
        2: punctuation.section.braces.begin.idk
      push:
        - match: \]
          scope: punctuation.section.braces.end.idk
          pop: true
        - include: main

  structdef:
    - match: ({{ident}})\s*(\{)
      captures:
        1: entity.name.struct.idk
        2: punctuation.section.brackets.begin.idk
      push:
        - match: ({{ident}})\s*({{type}})
          captures:
            1: meta.field.idk
            2: storage.type.idk

        - match: \}
          scope: punctuation.section.brackets.end.idk
          pop: true

        - include: expression
        - include: invalid

  expression:
    - include: comment

    - include: special
    - include: keyword
    - include: operator
    - include: grouping
    - include: subscript
    - include: array
    - include: number
    - include: string-char

    - include: definition_or_variable

  # DEFINITION

  definition_or_variable:
    # variable
    - match: (?=({{ident}}))
      branch_point: start_def_or_var
      branch:
        - definition
        - variable_or_call

  definition:
    - match: ({{ident}})\s+({{ident}})|({{ident}})
      captures:
        1: entity.name.class.idk
        2: entity.name.function.method.idk
        3: entity.name.function.idk
      push:
        - match: \(
          scope: punctuation.section.parens.begin.idk
          set:
            - match: '({{ident}})\s*({{type}})?'
              captures:
                1: variable.parameter.idk
                2: storage.type.idk
            - match: \,
              scope: punctuation.separator.sequence.idk
            - match: \.
              scope: keyword.operator.any.idk
            - match: \.\.\.
              scope: keyword.operator.variadic.idk
            - match: \)
              scope: punctuation.section.parens.end.idk
              set: finish_def

            - include: invalid

        - include: finish_def

  finish_def:
    - match: ({{type}})?\s*(=|:=)(?!>)
      captures:
        1: storage.type.idk
        2: keyword.operator.assignment.idk
      pop: 2

    - match: \S|$
      fail: start_def_or_var

  # EXPRESSION

  keyword:
    - match: \?\?
      scope: keyword.control.conditional.switch.idk
    - match: =>
      scope: keyword.control.conditional.switch.idk

    - match: =>
      scope: keyword.control.loop.for.idk

    - match: \?
      scope: keyword.control.conditional.if.idk
    - match: ':'
      scope: keyword.control.conditional.else.idk

  operator:
    - match: ->
      scope: keyword.operator.cast.idk
      push: type
    - match: <<|>>
      scope: keyword.operator.bitwise.shift.idk
    - match: ==|/=
      scope: keyword.operator.comparison.idk
    - match: <=|>=|<>|<|>
      scope: keyword.operator.relational.idk
    - match: \!|&&|\|\||\?\?|\^\^
      scope: keyword.operator.logical.idk
    - match: \&|\^|\|
      scope: keyword.operator.bitwise.idk
    - match: \*|/|-|\+|\%
      scope: keyword.operator.arithmetic.idk

    - match: \.\.
      scope: punctuation.definition.range.idk
    - match: \.
      scope: punctuation.accessor.dot.idk
    - match: \,
      scope: punctuation.separator.sequence.idk

  grouping:
    - match: \(
      scope: punctuation.section.parens.begin.idk
      push:
        - include: expression
        - match: \)
          scope: punctuation.section.parens.end.idk
          pop: true
        - include: invalid

  subscript:
    - match: \[
      scope: punctuation.section.brackets.begin.idk
      push:
        - include: expression
        - match: \]
          scope: punctuation.section.brackets.end.idk
          pop: true
        - include: comments
        - include: invalids

  array:
    - match: \[
      scope: punctuation.section.brackets.begin.idk
      push:
      - meta_scope: meta.array-elements.idk
      - match: \]
        scope: punctuation.section.brackets.end.idk
        pop: true
      - include: comment
      - include: expression
      - include: invalid

  # PRIMARIES

  number:
    - match: \b{{number}}\b
      scope: constant.numeric.idk

  special:
    - match: true|false
      scope: constant.language.boolean.idk
    - match: \(\)
      scope: constant.language.null.idk

  string-char:
    - match: '\"'
      push:
        - meta_scope: string.quoted.double
        - match: '\"'
          pop: true
        - include: escaped-char
        - include: format-specifier

    - match: "'"
      push:
        - meta_scope: string.quoted.single
        - match: "'"
          pop: true
        - include: escaped-char

  variable_or_call:
    - match: (?:({{ident}})\s+({{ident}})|({{ident}}))\s*(\()
      captures:
        1: variable.class.idk
        2: variable.function.method.idk
        3: variable.function.idk
        4: punctuation.section.arguments.begin.idk
      push:
        - include: comment
        - match: \)
          scope: punctuation.section.arguments.end.idk
          pop: 2
        - include: expression
        - include: invalid

    - match: '{{ident}}'
      scope: variable.idk
      pop: true

  # MISC

  invalid:
    - match: \S
      scope: invalid.idk

  comment:
    - match: '---'
      scope: punctuation.definition.comment.idk
      push:
        - meta_include_prototype: false
        - meta_scope: comment.block.idk
        - match: '---'
          pop: true

    - match: '--'
      scope: punctuation.definition.comment.idk
      push:
        - meta_scope: comment.line.idk
        - match: $\n?
          pop: true

  escaped-char:
    # - match: \\(?:\\|[abefnrtv\'"?]|[0-3][0-9]{0,2}|[4-7][0-9]?|x[a-fA-F0-9]+|u[a-fA-F0-9]{4}|U[a-fA-F0-9]{8})
    - match: \\(?:a|b|e|f|n|r|t|v|\\|\'|\"|0)
      scope: constant.character.escape.c
    - match: \\.
      scope: invalid.illegal.unknown-escape.c

  format-specifier:
      - match: |-
          (?x)%
            (\d+\$)?                                      # field (argument #)
            [#0\- +']*                                    # flags
            [,;:_]?                                       # separator character (AltiVec)
            ((-?\d+)|\*(-?\d+\$)?)?                       # minimum field width
            (\.((-?\d+)|\*(-?\d+\$)?)?)?                  # precision
            (hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?          # length modifier
            (\[[^\]]+\]|[am]s|[diouxXDOUeEfFgGaACcSspn%]) # conversion type
        scope: constant.other.placeholder.idk