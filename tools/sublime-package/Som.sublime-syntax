%YAML 1.2

---

name: Som
file_extensions: [som]
fileTypes: [som]
scope: source.som

variables:
  ident: '[A-Za-z_][A-Za-z_0-9]*'
  Ident: '[A-Z][A-Za-z_0-9]*'

  # numbers
  decimal: '\b[0-9]+(?:\.[0-9]+)?\b'
  binary: '\b0b[0-1]+\b'
  octal: '\b0c[0-7]+\b'
  hexadecimal: '\b0x[0-9a-fA-F]+\b'
  number: '{{decimal}}|{{binary}}|{{octal}}|{{hexadecimal}}'

  # basic types
  inttype: i\.(s|u)\.[0-9]+
  floattype: f\.(64|32|16)
  voidtype: v
  basictype: \$(?:{{inttype}}|{{floattype}}|{{voidtype}})

  # directives
  directive: '{{ident}}'
  #     no_redef|warn_redef|
  #     no_return|
  #     no_mangle|
  #     warn_no_def|
  #     static|
  #     enabled|disabled|
  #     llvm_asm|
  #     unreachable

contexts:
  prototype:
    #
    - include: comments

  main:
    # The main context is the initial starting point of our syntax.
    # Include other contexts from here (or specify them directly).
    - include: comment
    - include: directive
    - include: import
    - include: typedef
    - include: type
    - include: declaration
    - include: definition
    - include: expression
    - include: invalid

  type:
    # structs
    - match: \{
      scope: punctuation.section.braces.begin.som
      push:
        - meta_scope: meta.struct-type.som

        - match: '({{ident}})\s*(:)'
          captures:
            1: name.field.som
            2: punctuation.separator.som

        - include: type

        - match: \}
          scope: punctuation.section.braces.end.som
          pop: true

    # enum
    - match: \[(?=\s*{{Ident}})
      scope: punctuation.section.brackets.begin.som
      push:
        - meta_scope: meta.enum-type.som

        - match: '{{ident}}'
          scope: entity.name.constant.som

        - match: \]
          scope: punctuation.section.brackets.end.som
          pop: true

        - include: invalid

    # effect
    - match: (?<!!)!(?!!)
      scope: storage.modifier.effect.som

    # basic types
    - match: '{{basictype}}|((?<!\.){{Ident}})|''{{ident}}(?!'')|\.\.\.'
      scope: storage.type.som
      push:
        - match: ->
          scope: keyword.other.arrow.som
        - match: ;
          scope: punctuation.separator.sequence.som
        - match: (?=\S)
          pop: true

  finish_tuple_type:
    - match: \(
      scope: punctuation.section.parens.begin.som
      push:
      - meta_scope: meta.tuple-type.som
      - include: type
      - match: \)
        scope: punctuation.section.parens.end.som
        pop: open_parens

      - match: \S
        fail: open_parens

  # STATEMENTS

  directive:
    - match: (\!\!\.?)({{directive}})?
      scope: meta.directive.som
      captures:
        1: punctuation.definition.annotation.som
        2: variable.annotation.som

  import:
    - match: \#\s*!?\s*(?={{ident}})
      scope: keyword.import.som
      push: import_finish

  import_finish:
    - meta_scope: meta.import.som

    - match: (?<=::)\*
      scope: keyword.other.glob.som
      pop: true

    # normal path segment, might be last
    - match: '{{ident}}'
      scope: entity.name.namespace.som
      set:
        - match: (=>)\s*({{ident}})
          captures:
            1: keyword.operator.as.som
            2: entity.name.namespace.som
          pop: true

        - match: '::'
          scope: punctuation.accessor.som
          set: import_finish

        - match: (?=\S)
          pop: true

    # start of block which cannot be
    # followed by another segment
    - match: \{
      scope: punctuation.section.braces.begin.som
      set:
        - match: \,
          scope: punctuation.separator.sequence.som

        - match: \}
          scope: punctuation.section.braces.end.som
          pop: true

        # we need to push recursively bc `set` is used
        - match: (?=\S)
          push: import_finish

    - include: invalid

  typedef:
    - match: ({{ident}})\s*(:=)
      captures:
        1: name.type.som
        2: keyword.operator.typedef.som

  declaration:
    - match: ({{ident}})\s*(\[)(?=.*\]\s*:)
      captures:
        1: entity.name.function.som
        2: punctuation.section.brackets.begin.som

      embed: generic_embedded
      escape: (\])\s*(:)?
      escape_captures:
        1: punctuation.section.brackets.end.som
        2: punctuation.separator.som

    - match: ({{ident}})\s*(:)
      captures:
        1: entity.name.function.som
        2: punctuation.separator.som

  definition:
    - match: '{{ident}}(?=(\s*{{ident}})*\s*=)'
      scope: name.symbol.som
      push:
        - match: '{{ident}}'
          scope: variable.parameter.som
        - match: (=)(\s*\.\.\.)?
          captures:
            1: keyword.operator.definition.som
            2: keyword.operator.extern.som
          pop: true

  generic_embedded:
    - include: type
    - match: \,
      scope: punctuation.separator.sequence.som

  # EXPRESSION

  expression:
    - include: comment

    - include: special
    - include: operator
    - include: lambda
    - include: grouping
    - include: subscript
    - include: array
    - include: number
    - include: variable
    - include: string-char

  operator:
    - match: \?\?
      scope: keyword.operator.conditional.switch.som
    - match: ->
      scope: keyword.operator.switch-arm.som

    - match: =>
      scope: keyword.operator.do.som

    - match: \?
      scope: keyword.operator.ternary.if.som
    - match: ':(?!:)'
      scope: keyword.operator.ternary.else.som

    # - match: ->
      # scope: keyword.operator.cast.som

    - match: <<|>>
      scope: keyword.operator.bitwise.shift.som
    - match: =|/=
      scope: keyword.operator.comparison.som
    - match: <=|>=|<|>
      scope: keyword.operator.relational.som
    - match: \!|&&|\|\||\^\^
      scope: keyword.operator.logical.som
    - match: \&|\^|\|
      scope: keyword.operator.bitwise.som
    - match: \*|/|-|\+|\%
      scope: keyword.operator.arithmetic.som

    - match: \.\.
      scope: punctuation.definition.range.som
    - match: \.
      scope: punctuation.accessor.dot.som
    - match: ->
      scope: punctuation.accessor.arrow.som
    - match: \,|;
      scope: punctuation.separator.sequence.som

  lambda:
    - match: \\
      scope: keyword.other.lambda.som
      push:
        - match: '{{ident}}'
          scope: variable.parameter.lambda.som
        - match: =>
          scope: keyword.operator.definition.som
          pop: true

  grouping:
    - match: \(
      scope: punctuation.section.parens.begin.som
      push:
        - meta_scope: meta.grouping.som
        - match: \)
          scope: punctuation.section.parens.end.som
          pop: true
        - include: type
        - include: expression
        - include: invalid

  subscript:
    - match: \[
      scope: punctuation.section.brackets.begin.som
      push:
        - include: expression
        - match: \]
          scope: punctuation.section.brackets.end.som
          pop: true
        - include: comments
        - include: invalids

  array:
    - match: \[
      scope: punctuation.section.brackets.begin.som
      push:
      - meta_scope: meta.array-elements.som
      - match: \]
        scope: punctuation.section.brackets.end.som
        pop: true
      - include: comment
      - include: expression
      - include: invalid

  # PRIMARIES

  number:
    - match: \b{{number}}\b
      scope: constant.numeric.som

  special:
    - match: true|false
      scope: constant.language.boolean.som
    - match: \(\)
      scope: constant.language.null.som

  string-char:
    - match: '\"'
      push:
        - meta_scope: string.quoted.double
        - match: '\"'
          pop: true
        - include: escaped-char
        - include: format-specifier

    - match: "'"
      push:
        - meta_scope: string.quoted.single
        - match: "'"
          pop: true
        - include: escaped-char

  variable:
    - match: _(?!{{ident}})
      scope: constant.language.wildcard.som

    - match: ({{ident}})\s*(\:\:)
      captures:
        1: entity.name.namespace.som
        2: punctuation.accessor.double-colon.som

    - match: (?<=\.)({{Ident}})
      scope: entity.name.constant.som

    - match: '{{ident}}''*'
      scope: variable.som

  # MISC

  invalid:
    - include: comment
    - match: \S
      scope: invalid.som
      pop: true

  comment:
    - match: '---'
      scope: punctuation.definition.comment.som
      push:
        - meta_include_prototype: false
        - meta_scope: comment.block.som
        - match: '---'
          pop: true

    - match: '--'
      scope: punctuation.definition.comment.som
      push:
        - meta_scope: comment.line.som
        - match: $\n?
          pop: true

  escaped-char:
    - match: \\(?:a|b|f|n|r|t|v|\\|\'|\"|0|$)
      scope: constant.character.escape.som
    - match: \\.
      scope: invalid.illegal.unknown-escape.som

  format-specifier:
      - match: \%(d|s|f|c)
        scope: constant.other.placeholder.som